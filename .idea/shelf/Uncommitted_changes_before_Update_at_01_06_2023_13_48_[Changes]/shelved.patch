Index: GUI.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Pygame and other modules\r\nimport pygame as py\r\nimport sys\r\nimport pygame_widgets\r\nfrom pygame_widgets.dropdown import Dropdown\r\n\r\n\r\n# Project files\r\nimport utils\r\nimport menu_button as button\r\nimport theme\r\nfrom cases import Case\r\nfrom pawn import Pawn\r\nfrom dragger import Dragger   \r\nfrom move import Move\r\n\r\n\r\nclass Game():\r\n    def __init__(self):\r\n\r\n        # Create game Window\r\n        py.init()  # It is imperative to put this in the code, because it initializes all pygame modules\r\n        self.screen = py.display.set_mode(\r\n            (utils.SCREEN_WIDTH, utils.SCREEN_HEIGHT))  # Set the screen dimensions\r\n        py.display.set_caption('Quorridor')  # sets the screen title\r\n        self.clock = py.time.Clock()\r\n        self.dragger = Dragger()\r\n\r\n        # This is my console board\r\n        self.cases = [[0] * utils.COLS for i in range(utils.COLS)]\r\n        # Turn squares into instances of another class(will serve to add some properties)\r\n        for row in range(utils.ROWS):\r\n            for col in range(utils.COLS):\r\n                # Will give to each square the properties of the Case class\r\n                self.cases[row][col] = Case(row, col)\r\n\r\n        # Game state variables\r\n        # self.game_paused = False\r\n        self.game_state = 'menu'\r\n\r\n        # Move related variables\r\n        self.last_move = None  # I don't think I'll need but it can be useful\r\n        # self.player = \"white\"\r\n        self.player = \"white\"\r\n\r\n        # Pawns\r\n        self.red_pawn = Pawn('red')\r\n        self.white_pawn = Pawn('white')\r\n        self.black_pawn = Pawn('black')\r\n        self.green_pawn = Pawn('green')\r\n\r\n        # Load the pawn images\r\n        self.red_piece = self.red_pawn.img.convert_alpha()\r\n        self.white_piece = self.white_pawn.img.convert_alpha()\r\n        self.black_piece = self.black_pawn.img.convert_alpha()\r\n        self.green_piece = self.green_pawn.img.convert_alpha()\r\n\r\n        # Position the pawns in the console board\r\n        self.set_pawn_position(utils.ROWS//2, 0, \"red\")\r\n        self.set_pawn_position(utils.ROWS//2, -1, \"white\")\r\n        self.set_pawn_position(0, utils.ROWS//2, \"black\")\r\n        self.set_pawn_position(-1, utils.ROWS//2, \"green\")\r\n\r\n        # Load button images\r\n        help_img = py.image.load(\"assets\\\\help_button.png\").convert_alpha()\r\n        quit_img = py.image.load(\"assets\\\\quit_button.png\").convert_alpha()\r\n        start_img = py.image.load(\"assets\\\\start_button.png\").convert_alpha()\r\n        back_img = py.image.load(\"assets\\\\back_button.png\").convert_alpha()\r\n        resume_img = py.image.load(\"assets\\\\resume_button.png\").convert_alpha()\r\n\r\n        # create button instances\r\n        self.start_button = button.Button(\r\n            utils.width_prct(40),  # x position\r\n            utils.height_prct(25),  # y position\r\n            start_img,  # The image\r\n        )\r\n\r\n        self.help_button = button.Button(\r\n            utils.width_prct(40),\r\n            utils.height_prct(45),\r\n            help_img,  # The image\r\n        )\r\n\r\n        self.quit_button = button.Button(\r\n            utils.width_prct(40),\r\n            utils.height_prct(65),\r\n            quit_img,\r\n        )\r\n\r\n        self.back_button = button.Button(\r\n            utils.width_prct(60),  # x coordinate\r\n            utils.height_prct(85),  # y coordinate\r\n            back_img,\r\n        )\r\n\r\n        self.resume_button = button.Button(\r\n            utils.width_prct(25),\r\n            utils.height_prct(85),\r\n            resume_img,\r\n        )\r\n\r\n\r\n    # Show_methods\r\n    def show_board(self, screen):\r\n        screen.fill((119, 154, 88))  # Board color\r\n        for row in range(utils.ROWS):\r\n            for col in range(utils.COLS):\r\n\r\n                # Squares\r\n                # rectangle dimensions, the format is (row, col, width, height)\r\n                squares_rect = (col * utils.SQSIZE, row *\r\n                                utils.SQSIZE, utils.SQSIZE, utils.SQSIZE)\r\n                # Is the \"self\" really necessary?\r\n                self.squares = py.draw.rect(\r\n                    screen, theme.board_color, squares_rect, 1)\r\n\r\n\r\n    def show_walls(self, screen):\r\n        # test colors\r\n        RED = (255, 0, 0)\r\n        blc = (0, 0, 0)\r\n\r\n        for row in range(utils.ROWS):\r\n            for col in range(utils.COLS):\r\n                # Horizontal wall spots\r\n                horiz_rect = (\r\n                    col * utils.SQSIZE, \r\n                    (row+1) * utils.SQSIZE, \r\n                    utils.SQSIZE, \r\n                    10\r\n                    )\r\n                horizontal_walls = py.draw.rect(screen, RED, horiz_rect, 1)\r\n\r\n                # Vertical walls\r\n                vert_rect = (\r\n                    (col+1) * utils.SQSIZE, \r\n                    row * utils.SQSIZE, \r\n                    10, \r\n                    utils.SQSIZE\r\n                    )\r\n                vert_walls = py.draw.rect(screen, RED, vert_rect)\r\n\r\n                # Click handler\r\n                pos = py.mouse.get_pos()\r\n                if horizontal_walls.collidepoint(pos):\r\n                    # and self.clicked == False:\r\n                    if py.mouse.get_pressed()[0] == 1 and not self.dragger.dragging:\r\n                        # self.clicked = True\r\n                        horizontal_walls = py.draw.rect(\r\n                            screen, blc, horiz_rect, 1)\r\n\r\n                if vert_walls.collidepoint(pos):\r\n                    # and self.clicked == False:\r\n                    if py.mouse.get_pressed()[0] == 1:\r\n                        # self.clicked = True\r\n                        vert_walls = py.draw.rect(screen, blc, vert_rect, 1)\r\n\r\n\r\n    # Set the postion of each pawn in the console board\r\n    def set_pawn_position(self, row, col, color):\r\n        if color == \"white\":\r\n            self.cases[row][col] = Case(row, col, self.white_pawn)\r\n        elif color == \"red\":\r\n            self.cases[row][col] = Case(row, col, self.red_pawn)\r\n        elif color == \"black\":\r\n            self.cases[row][col] = Case(row, col, self.black_pawn)\r\n        elif color == \"green\": # Or you can use an else statement\r\n            self.cases[row][col] = Case(row, col, self.green_pawn)\r\n        return self.cases[row][col]\r\n    \r\n\r\n    # Display pawns\r\n    def show_pawns(self, screen):\r\n\r\n        for row in range(utils.ROWS):\r\n            for col in range(utils.COLS):\r\n                # I position the pawns in this loop\r\n                \r\n                if self.cases[row][col].has_pawn():  # Check if the square has a pawn\r\n                    pawn = self.cases[row][col].pawn\r\n\r\n                    if pawn is not self.dragger.pawn:\r\n                        # Draws(blits) the pawns and nothing else\r\n                        img_rect = col * utils.SQSIZE + utils.SQSIZE // 2, \\\r\n                            row * utils.SQSIZE + utils.SQSIZE // 2  # Put the piece at the center of the square\r\n\r\n                        if pawn.color == 'white':\r\n                            white_img = self.white_pawn.img\r\n                            white_rect = white_img.get_rect(center=img_rect)\r\n                            screen.blit(\r\n                                white_img,  # This is the image\r\n                                white_rect\r\n                            )\r\n\r\n                        elif pawn.color == 'red':\r\n                            red_img = self.red_pawn.img\r\n                            red_rect = red_img.get_rect(center=img_rect)\r\n                            screen.blit(\r\n                                red_img,  # This is the image\r\n                                red_rect\r\n                            )\r\n\r\n                        elif pawn.color == 'black':\r\n                            black_img = self.black_pawn.img\r\n                            black_rect = black_img.get_rect(center=img_rect)\r\n                            screen.blit(\r\n                                black_img,  # This is the image\r\n                                black_rect\r\n                            )\r\n                            \r\n                        elif pawn.color == 'green': # You can use an else\r\n                            green_img = self.green_pawn.img\r\n                            green_rect = green_img.get_rect(center=img_rect)\r\n                            screen.blit(\r\n                                green_img,  # This is the image\r\n                                green_rect\r\n                            )\r\n                        \r\n                        print(\r\n                            f\"{pawn.color}'s row: {self.cases[row][col].row}\")\r\n                        print(f\"{pawn.color}'s col: {self.cases[row][col].col}\")\r\n                        # print(f\"{self.white_pawn.color}'s row: {self.white_pawn.row}\")\r\n                        # print(f\"{self.white_pawn.color}'s col: {self.white_pawn.col}\")\r\n                        # print(f\"{self.black_pawn.color}'s row: {self.black_pawn.row}\")\r\n                        # print(f\"{self.black_pawn.color}'s col: {self.black_pawn.col}\")\r\n                        # print(f\"{self.green_pawn.color}'s row: {self.green_pawn.row}\")\r\n                        # print(f\"{self.green_pawn.color}'s col: {self.green_pawn.col}\")\r\n\r\n\r\n    def show_moves(self, screen):\r\n        if self.dragger.dragging:\r\n            pawn = self.dragger.pawn\r\n\r\n            # Loop all valid moves\r\n            for move in pawn.moves:\r\n                # color\r\n                color = 'cyan'  # You should definitely change this color\r\n                # color = 'blue' if (move.final.row+move.final.col) % 2 == 0 else 'lightblue'\r\n                # rect\r\n                rect = (move.final.col * utils.SQSIZE, move.final.row *\r\n                        utils.SQSIZE, utils.SQSIZE, utils.SQSIZE)\r\n                # blit\r\n                py.draw.rect(screen, color, rect)\r\n\r\n\r\n    def calc_moves(self, pawn, row, col): # Calc move works perfectly, at least it returns the right squares. It does return the right result\r\n        number = 0 # Don't think I really need this anymore, It was used to debug the chess problem\r\n        \"\"\"\r\n            Calculates the possible moves\r\n        \"\"\"\r\n        # if isinstance(piece, Pawn):\r\n        # A set of all possible movements\r\n        possible_moves = [\r\n            (row, col-1),  # left\r\n            (row, col+1),  # right\r\n            (row-1, col),  # up\r\n            (row+1, col)  # down\r\n        ]\r\n        for possible_move in possible_moves:\r\n            possible_move_row, possible_move_col = possible_move\r\n\r\n            if Case.in_range(possible_move_row, possible_move_col): # If the moves are in range of the board(if they don't exceed the board size)\r\n                if self.cases[possible_move_row][possible_move_col].empty():\r\n                    if not self.cases[possible_move_row][possible_move_col].has_pawn():\r\n                    \r\n                        # A debug, I think?\r\n                        if self.cases[possible_move_row][possible_move_col].pawn != None:\r\n                            print(number)\r\n\r\n                \r\n                        # Creates new cases\r\n                        initial = Case(row, col)\r\n                        final = Case(possible_move_row, possible_move_col)\r\n\r\n                        # Create new move\r\n                        move = Move(initial, final)\r\n                        pawn.add_move(move)\r\n\r\n                        number += 1\r\n                    \r\n                else: #self.cases[possible_move_row][possible_move_col].has_pawn(): # I can either use this condition to make the code perfect or I can just make a turn function and that should do the trick\r\n                    enemy_pos = self.cases[possible_move_row][possible_move_col]\r\n\r\n                    # It is 00:46 on the 11/05/2023, you are tired and your nested condition are getting messy. You should definitely check them and prevent them from jumping two squares\r\n                    if enemy_pos.row == row:\r\n                        possible_moves.append((enemy_pos.row, enemy_pos.col+1))\r\n\r\n                    elif enemy_pos.col == col:\r\n                        possible_moves.append((enemy_pos.row+1, enemy_pos.col))\r\n                    \r\n                    elif (enemy_pos.row == row) and (enemy_pos.col == col):  # Don't know if I could use an else instead\r\n                        possible_moves.append((enemy_pos.row+1, enemy_pos.col))\r\n                        possible_moves.append((enemy_pos.row, enemy_pos.col+1))\r\n                # elif self.cases[possible_move_row][possible_move_col].has_pawn():\r\n                    \r\n\r\n    def move_pawn(self, pawn, move):\r\n\r\n        initial = move.initial\r\n        final = move.final\r\n\r\n        self.cases[initial.row][initial.col].pawn = None\r\n        self.cases[final.row][final.col].pawn = pawn\r\n\r\n        # Move\r\n        # pawn.moved = True # Is it really important? Not really\r\n\r\n        # Clear valid moves\r\n        pawn.clear_moves()\r\n\r\n        # Sets last move\r\n        # self.last_move = move\r\n\r\n\r\n    # Check if a move is valid and prevents invalid ones\r\n    def valid_move(self, pawn, move):\r\n        if pawn != None:\r\n            return move in pawn.moves\r\n    \r\n\r\n    # Event handler\r\n    def check_events(self):\r\n\r\n        for event in py.event.get():\r\n            # Allows to quit the application correctly\r\n            if event.type == py.QUIT:\r\n                py.quit()\r\n                sys.exit()\r\n\r\n            if event.type == py.MOUSEBUTTONDOWN:\r\n                self.dragger.update_mouse(event.pos) # update the mouse position\r\n                clicked_row = self.dragger.pos_y // utils.SQSIZE # Returns the row that was clicked\r\n                clicked_col = self.dragger.pos_x // utils.SQSIZE # Returns the column that was clicked\r\n\r\n                if self.cases[clicked_row][clicked_col].has_pawn(): # Checks wether the clicked cell has a pawn\r\n                    pawn = self.cases[clicked_row][clicked_col].pawn # Stores the pawn from the clicked cell into the pawn variable\r\n\r\n                    if pawn.color == self.player:\r\n                        self.calc_moves(pawn, clicked_row, clicked_col)\r\n                        self.dragger.save_initial(event.pos) # Saves the initial position of the pawn\r\n                        self.dragger.drag_pawn(pawn)\r\n                        self.show_moves(self.screen)\r\n                    \r\n                    \r\n\r\n            if event.type == py.MOUSEMOTION:\r\n                # If we are dragging the pawn\r\n                if self.dragger.dragging:\r\n                    self.dragger.update_mouse(event.pos)\r\n                    self.show_moves(self.screen)\r\n                    self.dragger.update_screen(self.screen)\r\n\r\n            if event.type == py.MOUSEBUTTONUP:\r\n                if self.dragger.dragging:\r\n                    self.dragger.update_mouse(event.pos)\r\n\r\n                released_row = self.dragger.pos_y // utils.SQSIZE\r\n                released_col = self.dragger.pos_x // utils.SQSIZE\r\n\r\n                # Create possible move\r\n                initial = Case(self.dragger.initial_row, self.dragger.initial_col)\r\n                final = Case(released_row, released_col)\r\n                move = Move(initial, final)\r\n\r\n                # Checks if it is a valid move\r\n                if self.valid_move(self.dragger.pawn, move): # I stopped there, the valid move verification has an issue. I think it is most likely that the move isn't considered a valide one thus is not accepted, you should look more into it\r\n                # print('test successful')\r\n                    if self.dragger.pawn != None:\r\n                        self.move_pawn(self.dragger.pawn, move)\r\n                        self.turn(4) # You should really use a variable here\r\n\r\n                self.dragger.undrag_pawn()\r\n                \r\n\r\n    def turn(self, number):\r\n\r\n        if number == 2:\r\n            if self.player== \"white\":\r\n                self.player = \"red\"\r\n            else: self.player = \"white\"\r\n\r\n        if number == 3:\r\n            if self.player == \"white\":\r\n                self.player = \"red\"\r\n            \r\n            elif self.player == \"red\": self.player = \"green\"\r\n            else:\r\n                self.player = \"white\"\r\n\r\n        if number == 4:\r\n            if self.player == \"white\":\r\n                self.player = \"red\"\r\n\r\n            elif self.player == \"red\":\r\n                self.player = \"green\"\r\n            \r\n            elif self.player == \"green\": self.player = \"black\"\r\n            else:\r\n                self.player = \"white\"\r\n        \r\n\r\n\r\n    # Game loop\r\n    def mainloop(self):\r\n        # The dropdown lists don't work\r\n        board_sizes = Dropdown(\r\n            self.screen,\r\n            200,  # x\r\n            200,  # y\r\n            100,  # width\r\n            50,  # height\r\n            \"This is a test\",\r\n            [\"5x5\", \"7x7\", \"9x9\", \"11x11\"],\r\n            eventType=py.MOUSEBUTTONDOWN\r\n        )\r\n        # number_of_players = Dropdown(self.screen, 200, 300, 100, 50, [2, 3, 4])\r\n        # number_of_walls = Dropdown(self.screen, 200, 400, 100, 50, [20, 40, 80])\r\n        selected_board_size = 5\r\n        selected_number_of_players = 2\r\n        selected_number_of_walls = 20\r\n\r\n        while True:\r\n            self.screen.fill((250, 52, 25))  # Background color\r\n            self.check_events()\r\n\r\n            if self.game_state == \"menu\":\r\n                if self.start_button.display(self.screen):\r\n                    self.game_state = 'utils'\r\n                if self.help_button.display(self.screen):\r\n                    self.game_state = 'help'\r\n                if self.quit_button.display(self.screen):\r\n                    py.quit()\r\n                    sys.exit()\r\n\r\n            elif self.game_state == 'help':\r\n                if self.back_button.display(self.screen):\r\n                    self.game_state = 'menu'\r\n\r\n            elif self.game_state == 'game':\r\n                py.display.set_caption(f'QUORRIDOR! {self.player}\\'s turn')  # sets the screen title\r\n                self.show_board(self.screen)\r\n                self.show_moves(self.screen)\r\n                self.show_walls(self.screen)\r\n                self.show_pawns(self.screen)\r\n\r\n                if self.dragger.dragging:\r\n                    self.dragger.update_screen(self.screen)\r\n\r\n            elif self.game_state == 'utils':\r\n                if self.back_button.display(self.screen):\r\n                    self.game_state = 'menu'\r\n\r\n                if self.resume_button.display(self.screen):\r\n                    self.game_state = 'game'\r\n\r\n                # Below is a useless code\r\n                selected_board_size = board_sizes.getSelected()\r\n                # selected_number_of_players = int(number_of_players.getValue())\r\n                # selected_number_of_walls = int(number_of_walls.getValue())\r\n\r\n                # board_sizes.listen()\r\n                # number_of_players.listen()\r\n                # number_of_walls.listen()\r\n\r\n                board_sizes.draw()\r\n                # number_of_players.draw()\r\n                # number_of_walls.draw()\r\n\r\n            self.clock.tick(60)\r\n            py.display.update()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    game = Game()\r\n    game.mainloop()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/GUI.py b/GUI.py
--- a/GUI.py	(revision 9d1919adba3f4bd93603bd27222ee4240054bc5b)
+++ b/GUI.py	(date 1683993862268)
@@ -125,7 +125,7 @@
                 # Horizontal wall spots
                 horiz_rect = (
                     col * utils.SQSIZE, 
-                    (row+1) * utils.SQSIZE, 
+                    (row+1) * utils.SQSIZE,
                     utils.SQSIZE, 
                     10
                     )
@@ -142,13 +142,14 @@
 
                 # Click handler
                 pos = py.mouse.get_pos()
+
                 if horizontal_walls.collidepoint(pos):
                     # and self.clicked == False:
                     if py.mouse.get_pressed()[0] == 1 and not self.dragger.dragging:
-                        # self.clicked = True
+                        clicked = True
                         horizontal_walls = py.draw.rect(
                             screen, blc, horiz_rect, 1)
-
+                        print("bariere")
                 if vert_walls.collidepoint(pos):
                     # and self.clicked == False:
                     if py.mouse.get_pressed()[0] == 1:
@@ -216,9 +217,9 @@
                                 green_rect
                             )
                         
-                        print(
-                            f"{pawn.color}'s row: {self.cases[row][col].row}")
-                        print(f"{pawn.color}'s col: {self.cases[row][col].col}")
+                        # print(
+                        #     f"{pawn.color}'s row: {self.cases[row][col].row}")
+                        # print(f"{pawn.color}'s col: {self.cases[row][col].col}") 212
                         # print(f"{self.white_pawn.color}'s row: {self.white_pawn.row}")
                         # print(f"{self.white_pawn.color}'s col: {self.white_pawn.col}")
                         # print(f"{self.black_pawn.color}'s row: {self.black_pawn.row}")
Index: utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\nSCREEN_WIDTH = 800\r\nSCREEN_HEIGHT = 800\r\n\r\n\r\nROWS = 5\r\nCOLS = ROWS\r\nSQSIZE = SCREEN_WIDTH // COLS\r\n\r\n\r\n# PLAYERS = 0\r\n# NUM_WALLS = 0\r\n\r\n\r\n# Those functions help us position element onto the screen\r\ndef height_prct(percentage):\r\n    return (SCREEN_HEIGHT / 100) * percentage\r\n\r\n\r\ndef width_prct(percentage):\r\n    return (SCREEN_WIDTH / 100) * percentage\r\n\r\n\r\ndef get_number_of_walls():\r\n    pass\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils.py b/utils.py
--- a/utils.py	(revision 9d1919adba3f4bd93603bd27222ee4240054bc5b)
+++ b/utils.py	(date 1683993813929)
@@ -2,7 +2,7 @@
 
 SCREEN_WIDTH = 800
 SCREEN_HEIGHT = 800
-
+# 160*5=   800
 
 ROWS = 5
 COLS = ROWS
